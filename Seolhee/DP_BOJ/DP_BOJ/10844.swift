// BOJ 10844 쉬운 계단 수
/*
 [n = 1] 1 / 2 / 3 / 4 / 5 / 6 / 7 / 8 / 9
 [n = 2] 10 / 12 / 21 / 23 / 32 / 34 / 43 / 45 / 54 / 56 / 65 / 67 / 76 / 78 / 87 / 89 / 98
 [n = 3] 101 / 121 / 123 / 210 / 212 / 321 / 324 ....
 
 n이 1에서 2로 넘어오면서 1은 10, 12 그리고 2는 21, 23 등 두 개씩 파생되었다.
 하지만 9의 경우 98 하나로만 파생된 것을 확인할 수 있다.
 
 n이 2에서 3으로 넘어오면서 12는 121, 123 그리고 21은 210, 212 등 두 개씩 파생되는 것을 확인할 수 있다.
 하지만 10의 경우 101 하나만 파생된 것을 확인할 수 있다.
 
 이 문제의 경우, 모든 숫자를 알아내는게 아니라 그냥 갯수만 구하면 되는 문제임
 따라서 갯수를 구해줄 수 있는 점화식을 알아내주는게 제일 귯
 
 => P[n][m] = P[n-1][m-1] + P[n-1][m+1]
 */

let mod = 1000000000
let n = Int(readLine()!)!

if n == 1 { print(9) }
else {
    var dp = [0] + Array(repeating: 1, count: 9) // n이 1일 때 수 별로 경우의 수들을 넣어줌
    
    for _ in 2...n {
        let pre = dp
        
        dp[0] = pre[1] // pre[0-1] + pre[0+1] 인데, pre[-1]은 존재하지 않으므로 pre[1]만 넣어줌
        dp[9] = pre[8] // pre[9-1] + pre[9+1] 인데, pre[10]은 존재하지 않으므로 pre[8]만 넣어줌
        
        for j in 1...8 { dp[j] = (pre[j-1] + pre[j+1]) % mod }
    }
    
    print(dp.reduce(0, +) % mod)
}
