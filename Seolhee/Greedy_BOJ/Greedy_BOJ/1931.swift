// BOJ #1931 회의실 배정
//
// 하나의 2차원 배열을 앞 요소 기준으로 오름차순정렬한 후 뒤 요소 기준으로 다시 오름차순 정렬한다는 점이 포인트!
//
// times 배열의 한 요소안에는 [시작하는 시간, 끝나는 시간] 으로 회의 시간이 저장되는데,
// 시작하는 시간을 기준으로 먼저 정렬하고 그 후에 끝나는 시간으로 정렬했다.
// 여기서 중요한 점은, 어차피 모든 끝나는 시간은 해당 회의의 시작하는 시간보다 큰 수이므로
// 결국 정렬의 결과는 (시작하는 시간대로 정렬, 같은 시작하는 시간들 사이에서는 끝나는 시간대로 정렬) 이렇게 된다.
// 따라서 시작하는 시간이 같을 경우에는 그 중 가장 앞에 위치한 회의가 해당 시간에 존재하는 가장 짧은 회의라는것.
//
// => 시작하는 시간이 같은 회의 중 가장 짧은 회의를 고르고, 그 끝나는 시간 이후의 회의 중 또 가장 짧은 회의를 고르고.. 반복!

import Foundation

let count = Int(readLine()!)! // 회의 총 개수
var times = [[Int]]() // 회의 시작, 끝 시간 저장하는 2차원 배열
var answer = 0

for _ in 0..<count  {
    let input = readLine()!.split(separator: " ").map({Int(String($0))!})
    times.append([input[0], input[1]])
}

times.sort(by: { $0[0] < $1[0] }) // 시작하는 시간 기준 오름차순 정렬
times.sort(by: { $0[1] < $1[1] }) // 끝나는 시간 기준 오름차순 정렬

var check = 0

for i in times {
    if i[0] >= check {
        check = i[1]
        answer += 1
    }
}

print(answer)
